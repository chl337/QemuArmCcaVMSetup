#ifndef _HANDLER_H
#define _HANDLER_H
#include <stdint.h>
#include "process.h"
#include "hypercall.h"
#include "uart.h"
#include "exception_defines.h"

typedef struct _esr_el1 {
	uint64_t ISS:25;
	uint64_t IL:1;
	/*
 	 * Exception class: Indicates the reason for the exception that
	 * this registers holds information about.
	 */
	uint64_t EC:6;
	/* for a memory access generated by an ST64BV or STV64BV0 instruction a Data
	 * abort for Translation fault, access flag fault or permission fault, this
	 * field holds register specifier, Xs
	 * for any other data abort, this field is RES0
	 */
	uint64_t ISS2 : 5; //32-36
	uint64_t reserved : 27;//37-63
} esr_el1_t;

enum esr_el1_causes {
	EL1_EC_UKNOWN			= 0b000000,
	EL1_EC_Trap_WF			= 0b000001, 
	EL1_EC_Trap_MCR_MRC		= 0b000011, 
	EL1_EC_Trap_MCRR_MRRC		= 0b000100, 
	EL1_EC_Trap_MCR_MR    		= 0b000101, 
	EL1_EC_Trap_LDC_STC		= 0b000110, 
	EL1_EC_SVE_SIMD			= 0b000111, 
	EL1_EC_Trap_LDST64B		= 0b001010, 
	EL1_EC_Trap_MRRC		= 0b001100, 
	EL1_EC_BR_Target		= 0b001101, 
	EL1_EC_IllExec			= 0b001110, 
	EL1_EC_SVC_32			= 0b010001, 
	EL1_EC_SVC_64			= 0b010101, 
	EL1_EC_Trap_Other_Inst64	= 0b011000,
	EL1_EC_SVE_TRAP			= 0b011001, 
	EL1_EC_PTR_AUTH			= 0b011100, 
	EL1_EC_INST_ABORT_0		= 0b100000, 
	EL1_EC_INST_ABORT_1		= 0b100001, 
	EL1_EC_PC_ALIGN_FAULT   	= 0b100010, 
	EL1_EC_DATA_ABORT_0		= 0b100100, 
	EL1_EC_DATA_ABORT_1		= 0b100101, 
	EL1_EC_SP_ALIGN			= 0b100110, 
	EL1_EC_TRAP_FP_0		= 0b101000, 
	EL1_EC_TRAP_FP_1		= 0b101100, 
	EL1_EC_SError			= 0b101111, 
	EL1_EC_BP_Except_0 		= 0b110000, 
	EL1_EC_BP_Except_1		= 0b110001, 
	EL1_EC_SW_Step_0		= 0b110010, 
	EL1_EC_SW_Step_1		= 0b110011,
	EL1_EC_WP_0			= 0b110100, 
	EL1_EC_WP_1			= 0b110101, 
	EL1_EC_BKPT_32			= 0b111000, 
	EL1_EC_BKPT_64			= 0b111100, 
};

extern void kernel_system_call_entry_handler(context_t *ctx);
extern void hvc_call_exit_fatal(uint64_t reason);

void vm_exit_unhandled_exception(context_t *ctx)
{
	esr_el1_t *ptr = (esr_el1_t *) &ctx->esr_el1;
	hvc_call_exit_fatal(ptr->EC);
}
void trap_exception_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void abort_exception_handler(context_t *ctx)
{
	char *reason = 0;
	uint16_t cause = (uint16_t)((esr_el1_t*)(&ctx->esr_el1))->ISS & 0x3F;

	switch(cause) {
	case ISS_DATA_IFSFC_ADR_SZ_L0:
		reason = "ISS_DATA_IFSFC_ADR_SZ_L0";
		break;
	case ISS_DATA_IFSFC_ADR_SZ_L1:
		reason = "ISS_DATA_IFSFC_ADR_SZ_L1";
		break;
	case ISS_DATA_IFSFC_ADR_SZ_L2:
		reason = "ISS_DATA_IFSFC_ADR_SZ_L2";
		break;
	case ISS_DATA_IFSFC_ADR_SZ_L3:
		reason = "ISS_DATA_IFSFC_ADR_SZ_L3";
		break;
	case ISS_DATA_IFSFC_TF_L0:
		reason = "ISS_DATA_IFSFC_TF_L0";
		break;
	case ISS_DATA_IFSFC_TF_L1:
		reason = "ISS_DATA_IFSFC_TF_L1";
		break;
	case ISS_DATA_IFSFC_TF_L2:
		reason = "ISS_DATA_IFSFC_TF_L2";
		break;
	case ISS_DATA_IFSFC_TF_L3:
		reason = "ISS_DATA_IFSFC_TF_L3";
		break;
	case ISS_DATA_IFSFC_ACF_L0:
		reason = "ISS_DATA_IFSFC_ACF_L0";
		break;
	case ISS_DATA_IFSFC_ACF_L1:
		reason = "ISS_DATA_IFSFC_ACF_L1";
		break;
	case ISS_DATA_IFSFC_ACF_L2:
		reason = "ISS_DATA_IFSFC_ACF_L2";
		break;
	case ISS_DATA_IFSFC_ACF_L3:
		reason = "ISS_DATA_IFSFC_ACF_L3";
		break;
	case ISS_DATA_IFSFC_PERM_F0:
		reason = "ISS_DATA_IFSFC_PERM_F0";
		break;
	case ISS_DATA_IFSFC_PERM_F1:
		reason = "ISS_DATA_IFSFC_PERM_F1";
		break;
	case ISS_DATA_IFSFC_PERM_F2:
		reason = "ISS_DATA_IFSFC_PERM_F2";
		break;
	case ISS_DATA_IFSFC_PERM_F3:
		reason = "ISS_DATA_IFSFC_PERM_F3";
		break;
	case ISS_DATA_IFSFC_SEA:
		reason = "ISS_DATA_IFSFC_SEA";
		break;
	case ISS_DATA_IFSFC_TCF:
		reason = "ISS_DATA_IFSFC_TCF";
		break;
	case ISS_DATA_IFSFC_SEA_TL0:
		reason = "ISS_DATA_IFSFC_SEA_TL0";
		break;
	case ISS_DATA_IFSFC_SEA_TL1:
		reason = "ISS_DATA_IFSFC_SEA_TL1";
		break;
	case ISS_DATA_IFSFC_SEA_TL2:
		reason = "ISS_DATA_IFSFC_SEA_TL2";
		break;
	case ISS_DATA_IFSFC_SEA_TL3:
		reason = "ISS_DATA_IFSFC_SEA_TL3";
		break;
	case ISS_DATA_IFSFC_SEA_ECCNT:
		reason = "ISS_DATA_IFSFC_SEA_ECCNT";
		break;
	case ISS_DATA_IFSFC_SEA_ECC_TL:
		reason = "ISS_DATA_IFSFC_SEA_ECC_TL";
		break;
	case ISS_DATA_IFSFC_SEA_ECC_TL0:
		reason = "ISS_DATA_IFSFC_SEA_ECC_TL0";
		break;
	case ISS_DATA_IFSFC_SEA_ECC_TL1:
		reason = "ISS_DATA_IFSFC_SEA_ECC_TL1";
		break;
	case ISS_DATA_IFSFC_SEA_ECC_TL2:
		reason = "ISS_DATA_IFSFC_SEA_ECC_TL2";
		break;
	case ISS_DATA_IFSFC_SEA_ECC_TL3:
		reason = "ISS_DATA_IFSFC_SEA_ECC_TL3";
		break;
	case ISS_DATA_IFSFC_ALIGN_FAULT:
		reason = "ISS_DATA_IFSFC_ALIGN_FAULT";
		break;
	case ISS_DATA_IFSFC_ADRSZ_FAULT:
		reason = "ISS_DATA_IFSFC_ADRSZ_FAULT";
		break;
	case ISS_DATA_IFSFC_TRANS_FAULT:
		reason = "ISS_DATA_IFSFC_TRANS_FAULT";
		break;
	case ISS_DATA_IFSFC_TLB_ABORT:
		reason = "ISS_DATA_IFSFC_TLB_ABORT";
		break;
	case ISS_DATA_IFSFC_UNSUPPORTED:
		reason = "ISS_DATA_IFSFC_UNSUPPORTED";
		break;
	case ISS_DATA_IFSFC_IMPL_DEFINE_LOCKED:
		reason = "ISS_DATA_IFSFC_IMPL_DEFINE_LOCKED";
		break;
	case ISS_DATA_IFSFC_IMPL_DEFINE_ATOMIC:
		reason = "ISS_DATA_IFSFC_IMPL_DEFINE_ATOMIC";
		break;
	default:
		break;
	}
	if (reason) {
		uint32_t len = (uint32_t) strlen(reason);
		uart_send_byte_array((uint8_t*)reason, len);
	}
	vm_exit_unhandled_exception(ctx);
}
void sve_simd_fp_exception_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void unsupported_exception_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void system_exception_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void svc_exception_handler(context_t *ctx)
{
	kernel_system_call_entry_handler(ctx);
}

void debug_exception_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void stack_alignment_exception_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

uint64_t sync_handler(context_t *ctx)
{
	esr_el1_t *ptr = (esr_el1_t*)&ctx->esr_el1;	
	switch(ptr->EC) {
		/*traps*/
		case EL1_EC_Trap_MCR_MRC:
		case EL1_EC_Trap_MCRR_MRRC:
		case EL1_EC_Trap_MCR_MR:
		case EL1_EC_Trap_LDC_STC:
		case EL1_EC_Trap_WF:
		case EL1_EC_Trap_LDST64B:		
		case EL1_EC_Trap_MRRC:
			trap_exception_handler(ctx);
			break;
		/*aborts*/
		case EL1_EC_INST_ABORT_0:
		case EL1_EC_INST_ABORT_1:
		case EL1_EC_PC_ALIGN_FAULT:
		case EL1_EC_DATA_ABORT_0:
		case EL1_EC_DATA_ABORT_1:
			abort_exception_handler(ctx);
			break;
		case EL1_EC_SP_ALIGN:
			stack_alignment_exception_handler(ctx);
		case EL1_EC_SVE_SIMD: 
		case EL1_EC_TRAP_FP_0:
		case EL1_EC_TRAP_FP_1:
			sve_simd_fp_exception_handler(ctx);
			break;
		case EL1_EC_BP_Except_0:
		case EL1_EC_BP_Except_1:
		case EL1_EC_SW_Step_0:
		case EL1_EC_SW_Step_1:
		case EL1_EC_WP_0:
		case EL1_EC_WP_1:
		case EL1_EC_BKPT_32:
		case EL1_EC_BKPT_64:
		case EL1_EC_IllExec:
		case EL1_EC_BR_Target:
			debug_exception_handler(ctx);
		case EL1_EC_SVC_32:
		case EL1_EC_SVC_64:
			svc_exception_handler(ctx);
			break;
		case EL1_EC_Trap_Other_Inst64:
		case EL1_EC_SVE_TRAP:
			system_exception_handler(ctx);
			break;
		default:
			unsupported_exception_handler(ctx);
			break;	
	}
	return (uint64_t) ctx;
}

void irq_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void fiq_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void serror_handler(context_t *ctx)
{
	vm_exit_unhandled_exception(ctx);
}

void crash() 
{
	hvc_call_exit_fatal(-1UL);
}
#endif
